Spring		= https://spring.io/tools3/sts/legacy 들어가서 3.9.8 다운로드 받을것.

Android Studio	= https://developer.android.com/studio

|Browser| |Front_Controller(=Dispatcher Servlet)| |Factory|Controller|Service|
|-------|-|-------------------------------------|-|-------|----------|-------|
|.jsp|---request들-->|request의 단독 진입점.|-->|Controller Interface를 기반한 다양한 Controller가 등록되어있다. Wild Card Mapping을 통해 처리 대상 한정시킴.|Back단에 데이터를 요청하고,|

					<--	사용자의 request URL을 기반, 해당하는 Controller를 반환.			넘어온 데이터를 .jsp 에 담는다.			
Parser	<--response들-							------				....				-----> 						
	<-----실행------							<-----				....				------	데이터를 직접 보내지 않고		------>	
																		result.jsp 같이 페이지를 보낸다!	<------	

* Container 안에 데이터를 공유 할 수 있는 메모리 영역이 존재. (scoop에 따라 약 4개)
1) Context	가장 큰 scoop. 거의 쓰지 않는다. -> Container가 가지고 있는 모든 데이터를 Shutdown 될때까지 가지고 있는 역할.
2) Session	Default로 데이터에 Last Access 된 때부터 30분동안 데이터가 유지. Container에서 동작하는 Servlet과 jsp가 공유하는 데이터를 저장.
3) request	forward 방식에서 request에 심겨져 있는 데이터를 공유 할 수 있도록 저장. (SetAttribute를 통해 심음)
4) page		가장 작은 scoop. 거의 쓰지 않는다.

request : head/body/tail 세 부분으로 구성.
* Servlet과 일반 *.java 의 차이
- Servlet은 사용자의 요청과 응답을 Handling 할 수 있다. 일반 *.java는 HttpServlet을 상속받지 못하기 때문에, request와 response 객체를 Handling 할 수 없다.

* 데이터에 대한 유효성 체크?
1) Front-End쪽에서 Script를 통한 validation check가 이루어져야 함.
2) Filtering -> Front_Controller에서 Brower로 넘어가기 전에 데이터에 대한 유효성 체크. Why? -> 중간에 공격자가 개입해 데이터를 위변조 했을 수 있으므로!(MitM)
* MitM 공격은 두 당사자 사이에서 트래픽을 관찰하거나 조작하는 것으로 구성된다. 이는 정상적인 네트워크에 간섭을 일으키거나 공격자가 통제하는 가짜 네트워크를 생성해 가능하다.
그리고 나서 해킹된 트래픽은 암호화를 제거해 트래픽을 훔치거나 변경하거나 공격자가 원하는 목적지(피싱 로그인 사이트 등)로 전달한다. 공격자는 가로챈 트래픽을 기록하거나 수정한 후에는 조용히 관찰하거나 재암호화할 수 있기 때문에 공격을 찾아내기 어려울 수 있다.

* HTML : 구조, 스타일 / CSS : 데이터
