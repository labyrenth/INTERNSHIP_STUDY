1. JAVA의 특징.

                -
APPLICATION
-----       -   J
 API        J   D
-----       R   K
 JVM        E
-----       -   -
 O.S
-----
 H.W
 
 - 운영체제에 무관하게 JVM 에 의존. -> 어느 운영체제이든간에 JVM만 있으면 프로그램 하나 만들어도 잘 돌아간다!
 
 *.JAVA --COMPLIE--> *.CLASS (JAVA의 실행파일, byte code) --INTERPRITER--> OUTPUT
 
 - 객체지향
 
객체1  객체2  객체3 ...               
-----------------------REAL_WORLD
객체----[명사적 특징 Ex) 이름, 나이, 성별, 직업 ...    
        [동사적 특징 Ex) 움직인다, 먹는다, 잔다 ...
        
~> CLASS = 변수(명사적 특징) + 메서드(동사적 특징) 을 담은 탬플릿!
    + CLASS로부터 만들어진 객체 : 인스턴스. --> CLASS =/= INSTANCE ※중요!

소프트웨어 공학에서 말하는 좋은 프로그래밍 - 결합도(다른 인스턴스와의 관계)는 낮추고/응집력(내용의 통일성)은 높여야

JAVA는 대/소문자 구분. 클래스의 이름 = 자바파일 이름!

-> 클래스의 첫 문자 : 대문자. 변수/메서드의 첫 문자 : 소문자

** 클래스에 public static void main 메서드를 포함하는 클래스만 인터프리터가 가능. ~> 이 약속된 함수의 호출로부터 프로그램이 시작, 종료된다.

** 저장 순간에 complie을 하고 (문법적 오류 등 검사), 이는 즉 *.class 파일이 만들어졌다는 사실이다.

1) 변수의 지정 방식  -> 메서드가 처리할 데이터를 담는 그릇.
[ 접근지정자 데이타타입 변수명; ]

* Java의 접근지정자
1) public 2) private 3) protected 4) default(friendly)

* 데이터타입

기본      ---     숫자형   - 정수   : byte(1byte), short(2byte), int(4byte), long(8byte)
                          - 실수   : float, double
                  문자형           : char(2byte)
                  논리형           : boolean(1byte)
                  
기본 아닌 놈들은 다 참조로 생각하면 된다
* 기본 vs 참조
기본 -> 값을 담는다
참조 -> 값이 아닌, 주소값을 담는다. ~> 클래스를 통해 생성된 인스턴스는 메모리 어딘가에 주소값을 가지고, 참조는 이 인스턴스의 주소값을 지닌다.

2) 메서드의 지정 방식
[ 접근지정자 리턴타입  메서드이름 (파라미터)]
+ 리턴타입
1) 파라미터가 있고, 리턴이 있는 경우
2) 파라미터가 있고, 리턴이 없는 경우
3) 파라미터가 없고, 리턴이 있는 경우
4) 파라미터가 없고, 리턴이 없는 경우

* 이때 리턴 타입을 기본 타입 -> 값을 넘김, 참조타입 -> 주소를 넘김

** String : Java에서 기본적으로 제공해주는, '클래스' -> 타입이 아님!
-> System 이나 String 같은 기본 클래스는 java.lang.* 패키지에 존재.

---------------------------------------

2) package
- 보통 비슷한 기능들을 하는 클래스들을 모아놓는 저장소.
- package의 이름만 보고도 내가 원하는 기능을 하는 클래스가 이 패키지에 포함되어있구나! 하도록 만드는 것이 Best.
- 서로 다른 package의 클래스가 다른 package의 클래스를 쓰려면 import를 해야.
  + 이때 *로 참조하는 습관은 좀 버릴것. 성능차이 많이 날 가능성 높다
  
3) Instance
- 참조타입에서 주소값의 소유 주체.
- java에선 데이터타입(참조) 변수명  = new 데이터타입();  <- 이를 생성자라고 함.


**** Back단의 작업은 세가지 레이어로 나뉠 수 있다. -> 이 각각의 레이어가 시행하는 작업에 맞는 클래스를 만들어야.
* VO, DTO, ENTRIY

1) presentation layer
2) business/service layer
3) persistance layer

이때 BROWER <-> PRESENTATION <-> BUSINESS <-> PERSISTANCE <-> DATABASE 간에 통신함.
        |VIEWER| CONTROLLER |   |         MODEL         | -> MVC 모델!
        
ORACLE의 RESULT SET을 담을 데이터 타입이 기본적으로 JAVA에는 없으므로, RESULT SET의 행 하나하나를 하나의 인스턴스로 봄.
-> VO 클래스를 만들어, RESULT SET의 레코드의 값을 담을 인스턴스의 틀을 만든다. -> 배열에 넣는다.

MYBATIS -> SQL, 저장프로시저 그리고 몇가지 고급 매핑을 지원하는 퍼시스턴스 프레임워크

=> 하여튼 클래스를 만들때, 클래스 간의 관계를 잘 고려해야한다!

** 인스턴스 소유가 아닌 메서드? -> 생성자(Constructor)
~> 클래스 구성은 변수 + 생성자 + 메서드 로 이루어진다!
- 생성자는 클래스의 이름과 대/소문자까지 동일해야하고, 무조건 Public.
- 보통 인스턴스 초기화에 많이 이용. 전역변수에 다이렉트로 초기값을 주는것은 별로 좋은 방식이 아님을 유의.

* this. 키워드가 붙은 변수는 인스턴스의 소유가 되는 변수. 메서드 내부에선 지역변수가 전역변수보다 우선시 되므로, 파라미터와 전역변수의 이름이 같을 경우 이 키워드를 통해 전역변수를 구별해주어야 함.
this.name = name;
만약 name = name 할경우? 지역변수 name의 값이 지역변수 name의 값이 된다!

-----------------------------------------------------------

- 지역변수의 라이프 사이클은 해당 지역변수가 포함된 메소드의 라이프 사이클과 같다.
- 전역변수의 라이프 사이클은 인스턴스의 라이프 사이클과 같다.

- Static 이라는 키워드가 붙여진 변수나 메소드는 '인스턴스'의 소유가 아닌, '클래스' 의 소유로 간주한다. -> 별도의 메모리에 따로 올라간다.
  + Static 변수의 라이프사이클은 쓰레드와 같이 한다. why? 자바는 Thread 기반.
- JAVA에서 Static은 보통 final 키워드와 같이 쓰인다.

-----------------------------------------------------------

- Garbage Collector의 실행 시점은 보통 랜덤.
- GC Thread가 돌면서 

-----------------------------------------------------------
* 리터럴
- 프로그램에서 사용하는 모든 숫자, 문자, 논리값(true, false)을 일컫는 말.
- 리터럴은 프로그램이 시작할 때 시스템에 같이 로딩되어, 특정 메모리 공간(HEAP 공간에 존재) 인 상수 풀(Literal pool)에 놓인다.
Ex) int num = 3; 문장에서 값 3이 메모리 공간 어딘가에 존재해야 num 변수에 그 값을 복사할 수 있다.
 즉 숫자가 변수에 대입되는 과정 = 1) 변수에 할당될 숫자값이 어딘가 메모리에 쓰여있음 2) 변수 메모리에 해당하는 value가 들어있는 literal pool의 key 값이 저장됨.

** Java에서 참조형 타입이면서 일반 타입처럼 사용할 수 있는 유일한 변수 : String
import test.model.str.StringBiz;

public class StringMain {

	private StringBiz biz;
	
	public static void main(String[] args) 
	{
		biz = new StringBiz();
	}
}

-> 오류난다. why? Memory에 로드되는 시점의 문제.
  + Static은 로딩되면서 생성되고, non static 필드는 그 다음에 생성된다.
  즉, static 사용 시점에 사용하고자 하는 인스턴스의 정의가 생성되어 있는지 안 되어 있는지 알 수 없기때문에 static에 인스턴스 변수를 사용할 수 없다.

# JAVA 메모리 관리 구조 #
1) TEXT AREA    : 기계어로 된 프로그램의 로직이 위치하는 메모리 영역
2) STATIC AREA  : 전역적 성격의 static 형 필드가 생성되는 메모리 영역
3) HEAP AREA    : new 연산자를 통해서 인스턴스 필드가 생성되는 메모리 영역
4) STACK AREA   : 함수의 실행시 생성되는 함수 변수 (로컬변수, 자동 변수)가 생성되는 메모리 영역.

--------------------------------------------------------------------
※ equals Operator와 == 연산자의 차이
  + ==는 주소, equals는 값을 비교한다.
