- 사실 깊게 파고들면 책한권 뚝딱이긴 한데, 이번 강의에선 가볍게 나갈것.

Stream : 데이터가 지나다닐 수 있는 통로.
	+ Scanner는 System이란 변수가 가지고 있는 in을 집어 넣었다.(참조타입일 것이고) 
		++ 이때 in은 InputStream 타입. 1Byte를 입력받는다! 하지만 한글을 넣어도 깨지지 않았다...
			+++ 잘 모르겠으면 System.in 안에 내부적으로 2Byte를 받아들일 수 있는 방법이 있다고만 알아두자.
		++ 다만 우리는 편하게 Scanner sc = new Scanner(System.in); 을 통해서 사용.
	+ 내부적으로 Stream의 역할을 해 줄 수 있는 객체가 있었을 것.
- 보편적으로 Byte와 Chracter 형식으로 데이터 입/출력. 
	+ 이때 한글로 Byte 계열의 데이터 입/출력을 하면 깨진다. Why? 2Byte 이므로!
- java.io.* 에 잔뜩 들어있다.
- 보편적인 Stream은 단방향. ~> 입출력을 하고 싶으면 두개의 Stream을 만들어야 한다!!!
- Stream은 꼭 사용 한 후 Close해야 함. > 만약 Close 안할 경우 문제가 생길 수 있다.

크게 3가지 -> 콘솔을 이용한 입출력, 파일을 이용한 입출력, 원격에 있는 다른쪽과 통신(네트워크, 소켓 통신이 필요.)
- 

Byte          | char
--------------|--------------
xxxStream     | xxxReader/Writer

- xxxReader(xxxStream) ~> 매개변수로 받을 수 있다.

Source <---데이터 입출력을 위한 통로---> Destination
       -------------Read------------->
       <-----------Write--------------
       
- 로컬이 아닌, 물리적인 네트워크를 통해서 전달할 시 통신 객체를 어떻게 할 것인가?
	+ xxxVO를 통해, 객체에 변수 값을 담고, Stream을 통해 전달.
	+ Byte 계열에 Object로 객체타입을 가지는 Input/Output의 Stream이 있다.
	+ 1Byte지만 Object를 전달 가능. -> 보내고자 하는 객체를 직렬화(serializable)이라는 인터페이스를 Implements 해서 마킹한 뒤 보내면 Object가 1byte로 쪼개져서 전달.
		++ 마킹 인터페이스 : 인터페이스인데 추상 메서드가 없는 인터페이스 -> 그냥 Implements만 하면 된다!
		++ 보내고자 하는 객체를 실타래, Stream을 바늘구멍이라 생각하면 Serializable를 통해 실타래를 풀어 실로 만들고, 바늘구멍을 통과 해 목적지에 도착한 뒤, 목적지에서 다시 실타래로 만드는 것.

- 즉, 최종적으로 Stream을 통해 보낼 수 있는 객체는 3개
1) Byte
2) Chracter
3) Serializable을 통해 Byte화 된 Object

- 만약 빅데이터 관련해서 통신해야한다면, Java와 Python간에 소켓통신을 해야한다.

Browser		| WAS		| Controller
		| listener	|
----------------|---------------|----------------
html5		|		| 
css3		|		|

			|			MODEL			|
			|-----------------------------------------------|
Presentation Layer	| Business Layer	| persistance Layer	|
------------------------|-----------------------|-----------------------|
1) Servlet.java		| xxxService(Interface)	| xxxDAO(Interface)	|
- Controller (xxDTO)	|			|			|
2) *.jsp		| xxxServiceImplements	| xxxDAOImplements	|
- View			|			|			|

Browser --Requset-> View <-> Controller <-> Model
	<-Response-
	
- 이때 Servlet이나 *.jsp는 엄연히 백엔드에 속한다. ~> 서버 계열의 언어로 친다.
- Browser는 화면을 Decoration 하는 역할을 한다.

* NodeJS 같이 JavaScript를 Controller로 사용하는 방법도 가능.
* URL을 Servlet에서 처리되는데, 사용자 리퀘스트 당 1개의 Servlet이 생성되므로 서로 다른 리퀘스트가 들어올 경우 리퀘스트의 종류와 같은 수의 Servlet이 만들어져야 한다.
	+ 사용자의 리퀘스트 자체가 바로 Servlet과 직접 통신하는 것이 아니라, '대문' 을 만들면 된다.
	+ 단일 진입 지점을 만들게 되므로, 관리가 더 편해지게 된다.
	+ 이 대문을 Front-Controller 또는 퍼사드(facade) 패턴
		++ facade 패턴 : 같은 어떤 소프트웨어의 다른 커다란 코드 부분에 대한 간략화된 인터페이스를 제공하는 객체

* FrontController가 다양한 Controller들을 제어해 주어야 하는데 어떻게 하나? 
- 다양한 Controller를 하나의 인터페이스 Controller로 모으고, 중간에 Singleton Factory를 하나 둔다.
	+ Factory는 FrontController에게 Controller 를 넘기고, FrontController가 메소드를 실행하면 각 Controller의 내부 구성을 전혀 몰라도 가능.
	+ 이때 Controller는 동일한 이름의 메서드에 대해 비슷한 기능으로 구현하고 있어야 함.

---------------------------------------
* View-FrontController-Factory-Ctrl-service-DAO-service-Ctrl-FrontController-View-메인에서 짠
