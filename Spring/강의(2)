filter		: Servlet을 건드린다. web.xml에서 설정.
// Web은 Interceptor와 AOP를 쓸 수 없다.
interceptor	: parameter 값을 확인, 바른 parameter 값이 적합하지 않으면 Interceptor에서 응답. servlet-context.xml에서 설정.

AOP		: Aspect of Programming -> Spring에서 관리하는 영역의 실행 전/후를 처리. 5개의 시점을 가지고 있다. root-context.xml에서 설정.

User -> filter -> DispatcherServlet -> Interceptor ->	| Controller ....
							| Spring에서 관리하는 영역
							
* filter는 사용자의 요청이 POST 방식일때만 적용 가능. GET 방식일때는 사용 불가!
	- 굳이 filter를 하려고 하면 복잡한 변형과정이 필요하기 때문에, 보통 GET방식은 영어/숫자로만 값을 받는게 대부분.
	
@RequestParam = Request.getParameter와 유사.

@RequestParam(name = "id", required=true) 시에, 해당 name에 매핑되는 객체가 null 이면 안된다.

@RequestMapping(value="/login.sinc", method=RequestMethod.POST)
	public String login(UserVO user, HttpSession session)
	{
		System.out.println("user ctrl login");
		UserVO result = service.loginService(user);
		if(result != null)
		{	
			session.setAttribute("user", user);
			System.out.println(result);
			return "redirect:/index.sinc";
		}
			//Spring에서 리다이렉트를 하는 방법
		else
		{
			System.out.println("ID Not EXIST");
			return "redirect:/loginForm.sinc";
			//원래의 LoginForm으로 돌아가게 해야!
		}
	}

이렇게 써도 되는데(세션에 데이터를 다이렉트로 심는다),

@Controller
@RequestMapping("/user")
//model의 scope이 Session으로 변경.
@SessionAttributes({"loginUser"})
public class UserCtrl 
{
	@Resource(name = "userS")
	private UserService service;
	
	@RequestMapping("/loginForm.sinc")
	public String loginForm()
	{
		return "/user/login";
	}
	
	@RequestMapping(value="/login.sinc", method=RequestMethod.POST)
	public String login(UserVO user, Model model)
	{
		System.out.println("user ctrl login");
		UserVO result = service.loginService(user);
		if(result != null)
		{	
			model.addAttribute("loginUser", result);
			System.out.println(result);
			return "redirect:/index.sinc";
		}
			//Spring에서 리다이렉트를 하는 방법
		else
		{
			System.out.println("ID Not EXIST");
			return "redirect:/loginForm.sinc";
			//원래의 LoginForm으로 돌아가게 해야!
		}
	}
}

으로 간접적으로 심어도 된다.
